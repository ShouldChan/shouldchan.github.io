<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta name="viewport" content="width=932" >
  <meta name="MobileOptimized" content="932" >
  <meta name="generator" content="ShouldChan">
  <title>线性回归</title>

  <link rel="stylesheet" type="text/css" href="/css/normalize.css">
  <link rel="stylesheet" type="text/css" href="/css/awe.css">
  <link rel="stylesheet" type="text/css" href="/css/social-likes.css">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="">

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="/js/imgLiquid-min.js"></script>
  <script src="/js/social-likes.min.js"></script>
</head>

<body>
  <div class="main-container">
    

<div class="box profile">
  <div class="heading" style="background: #3e5354 url(/images/bg-heading.jpg) no-repeat;">
    <div class="profile-img">
      <a href="//shouldchan.github.io/"><img src="/images/img-profile.jpg" width="154" height="150" alt="image description"></a>
    </div>
    <strong class="user"><a href="/">ShouldChan</a></strong>
    <span class="locate">Suzhou</span>
  </div>
  <div class="setting">
    <a href="//shouldchan.github.io/" class="btn-profile">Profile</a>
    <a href="/" class="btn-photos">Photos</a>
    <a href="/" class="btn-follow">Follow me</a>
  </div>
</div>

    
<div class="two-columns post-page">
  <div class="content">

    <div class="post box nocover">
      <em class="date"><span>06</span>Nov</em>
      <h2 class="post-title"><a href="/2017/11/06/线性回归/">线性回归</a></h2>
      <div class="post-content"><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>线性回归是一种监督学习方法，可以被用来解决回归问题。它用一条直线或高维空间中的平面来拟合训练数据，进而对未知数据进行预测。<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_1.jpg" alt="linear regression"></p>
<h1 id="基本套路"><a href="#基本套路" class="headerlink" title="基本套路"></a>基本套路</h1><p>这里介绍一下机器学习方法的基本套路：模型，代价函数，优化方法。<br>首先你得设计一个模型用于预测未知世界，然后针对这个模型要确定一个代价函数（cost function），这里代价函数就是我们常提的损失函数，英文学名loss function。损失函数越小，就表示模型拟合的越好。所以损失函数或代价函数是用来度量拟合程度的。<br>最后使用优化方法（optimization approach）在已有的样本数据上不断地优化模型参数。用的最多的优化算法主要是梯度下降。计算过程都需要计算参数梯度值。</p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_2.jpg" alt="basis model"><br>X表示样本特征，为n维向量，\theta为模型参数，为n+1维向量，包括一个偏置\theta_0</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_3.jpg" alt="cost function"><br>这个公式也叫做平方误差，m为样本个数，{X^(i),y^(i)}为第i个样本。</p>
<h2 id="参数梯度"><a href="#参数梯度" class="headerlink" title="参数梯度"></a>参数梯度</h2><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_4.jpg" alt="parameter gradient"><br>上述公式中，\theta_j表示第j个参数，X_j^(i)表示样本X^(i)的第j个特征值。</p>
<p>线性回归问题是可解的，只是当样本维度较大的时候很难求解才使用优化迭代的方法来逼近。如果样本维度不是很大的情况下，是可以解方程一次性得到样本参数，就像我们本科线性代数里学的那个样。</p>
<h2 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h2><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_5.jpg" alt="least square method"><br>这里的X是一个m\times n矩阵，n为特征维度，m为样本个数；y为m\times 1向量，表示每个样本的标签。</p>
<h2 id="加权最小二乘"><a href="#加权最小二乘" class="headerlink" title="加权最小二乘"></a>加权最小二乘</h2><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_6.jpg" alt="weighted least square method"><br>W为m\times m对角矩阵，对角线上的每个值表示对应样本的实例的权重。</p>
<h1 id="应用套路"><a href="#应用套路" class="headerlink" title="应用套路"></a>应用套路</h1><p>在实际应用中，在基本套路上会有一些小变化。下面从模型、代价函数以及参数梯度来描述。<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_7.jpg" alt="practical model"></p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>为了防止过拟合，一般会在代价函数上增加正则项，常见的正则方法有：<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_8.jpg" alt="regularization方法"></p>
<p>加上正则项后，代价函数编程如下形式：<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_9.jpg" alt="cost function with regularization"><br>\lambda 为正则项系数，\alpha为ElasticNet参数，他们都是可调整的超参数。ElasticNet 是一种使用L1和L2先验作为正则化矩阵的线性回归模型.这种组合用于只有很少的权重非零的稀疏模型，比如:class:Lasso, 但是又能保持:class:Ridge 的正则化属性.我们可以使用 l1_ratio 参数来调节L1和L2的凸组合(一类特殊的线性组合)。<br>当\alpha=0时，则为L2正则；当\alpha=1时，则为L1正则。L1正则项增加1/m以及L2正则项增加1/2m系数，仅仅是为了求导后的形式规整一些。</p>
<p>由于L1正则项不可导，如果\alpha不为0，那么不能简单的套用梯度下降或 L-BFGS，需要采用借助软阈值(Soft Thresholding)函数解决，如果是使用拟牛顿法，可以采用OWL-QN，它是基于L-BFGS算法的可用于求解L1正则的算法。基于上述代价函数，下面仅列出包含L2正则项时的参数梯度：<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_10.jpg" alt="parameter gradient with L2"><br>带星号的\theta_j为上一次迭代得到的参数值。</p>
<p>In fact，使用L2正则，是将前面所述的最小二乘方程改成如下形式：<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_11.jpg" alt="改写形式"></p>
<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p>一般来说，一个特征的值可能在区间 (0,1)之间，另一特征的值可能在区间(−∞,∞)，这就是所谓的样本特征之间量纲不同，这样会导致优化迭代过程中的不稳定。</p>
<p>当参数有不同初始值时，其收敛速度差异性较大，得到的结果可能也有较大的差异性，如下图所示，可以看到X和Y这两个变量的变化幅度不一致，如果直接使用梯度下降来优化迭代，那么量纲较大的特征信息量会被放大，量纲较小的特征信息量会被缩小。<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_12.jpg" alt=""></p>
<p>所以一般要对数据作无量纲化处理，通常会采用标准化方法 (x−u)/\sigma，得到如下数据分布，这样无论从哪个点开始，其迭代方向的抖动都不会太大，每个特征的信息也不至于被放大和缩小。<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/linear_regression_13.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>线性回归很少用于解决实际问题，但很适合对机器学习的入门。</p>
</div>

      <div class="bottom-panel">
        <ul class="social-likes" data-url="/2017/11/06/线性回归/">
          <li class="facebook" title="like"></li>
          <li class="twitter" title="twitte"></li>
          <li class="plusone" title="google"></li>
        </ul>
      </div>
    </div>
    
  </div>

  <div class="widgetarea">

    
    

<div class="tagcloud" id="fbox-tagcloud" style="margin:10px; display:none; overflow: hidden"><a href="/tags/Machine-Learning/" style="font-size: 12px;">Machine Learning</a></div>

    

    
      

<ul class="widget blogroll">
  <h3 class="title">Recent Post</h3>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2018/07/17/关于隐反馈的一些个人见解/">关于隐反馈的一些个人见解</a></h3>
        <p>关于隐反馈的一些个人见解显式反馈和隐式反馈的区别显式反馈中，矩阵中的每个元素1-5代表用户对物品的喜</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2017/12/08/集成学习下/">集成学习下</a></h3>
        <p>横跨快有两周的时间了，补一下集成学习下的内容。上上周写了集成学习上的博客，在那一块知识，有一个很典型</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2017/11/26/集成学习上/">集成学习上</a></h3>
        <p>周中在实验室seminar上做了一个有关集成学习的报告，趁周末有空，把集成学习的相关内容写个博客。我</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2017/11/07/奇异值分解/">奇异值分解</a></h3>
        <p>简介奇异值分解（Singular Value Decomposition，SVD）是矩阵分解的一种，</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2017/11/06/线性回归/">线性回归</a></h3>
        <p>线性回归线性回归是一种监督学习方法，可以被用来解决回归问题。它用一条直线或高维空间中的平面来拟合训练</p>
      </div>
    </li>
  
</ul>


    

  </div>
</div>


  </div>
  
<div class="footer">
  <div class="container">
    <a href="//github.com/kywk/hexo-theme-awe">AWE for hexo</a> inspired by <a href="http://goo.gl/H8OMRE">Awesome UI Kit</a>,
    ported by <a href="//kywk.github.io/">MooCow (Aka. kywk)</a>.
    
    &copy; 2018 Should Chan All Rights Reserved
    
  </div>
</div>

  <!-- disqus -->



<script>
$(document).ready(function() {
  $('.imgLiquid').imgLiquid({fill:true, fadeInTime:500});
});
</script>


<!-- fancybox -->
<link rel="stylesheet" href="/package/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="/package/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<script type="text/javascript">
(function($){
  $(".fancybox").fancybox();
  $(".various").fancybox({
    maxWidth  : 800,
    maxHeight : 600,
    fitToView : false,
    width   : '70%',
    height    : '70%',
    autoSize  : true,
    closeClick  : false,
    openEffect  : 'none',
    closeEffect : 'none'
  });
})(jQuery);
</script>

</body>
</html>
