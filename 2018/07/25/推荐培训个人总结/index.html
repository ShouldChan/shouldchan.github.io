<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta name="viewport" content="width=932" >
  <meta name="MobileOptimized" content="932" >
  <meta name="generator" content="ShouldChan">
  <title>推荐培训个人总结</title>

  <link rel="stylesheet" type="text/css" href="/css/normalize.css">
  <link rel="stylesheet" type="text/css" href="/css/awe.css">
  <link rel="stylesheet" type="text/css" href="/css/social-likes.css">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="">

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="/js/imgLiquid-min.js"></script>
  <script src="/js/social-likes.min.js"></script>
</head>

<body>
  <div class="main-container">
    

<div class="box profile">
  <div class="heading" style="background: #3e5354 url(/images/bg-heading.jpg) no-repeat;">
    <div class="profile-img">
      <a href="//shouldchan.github.io/"><img src="/images/img-profile.jpg" width="154" height="150" alt="image description"></a>
    </div>
    <strong class="user"><a href="/">ShouldChan</a></strong>
    <span class="locate">Suzhou</span>
  </div>
  <div class="setting">
    <a href="//shouldchan.github.io/" class="btn-profile">Profile</a>
    <a href="/" class="btn-photos">Photos</a>
    <a href="/" class="btn-follow">Follow me</a>
  </div>
</div>

    
<div class="two-columns post-page">
  <div class="content">

    <div class="post box nocover">
      <em class="date"><span>25</span>Jul</em>
      <h2 class="post-title"><a href="/2018/07/25/推荐培训个人总结/">推荐培训个人总结</a></h2>
      <div class="post-content"><p>针对2018年7月20日至21日的推荐培训课程做的学习总结。<br>根据本人对所学知识的梳理，本次培训主要内容有用户画像、特征工程、推荐算法以及评估指标这四个方面。</p>
<h1 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h1><p>首先，关于用户画像，主要了解什么是用户画像以及用户画像用来干什么。<br>用户画像是建立在一系列真实数据之上的目标用户模型。通过用户调研去了解用户，根据他们的目标、行为和观点的差异,将他们区分为不同的类型,然后每种类型中抽取出典型特征,赋予名字、照片、一些人口统计学要素、场景等描述，就形成了一个人物原型。<br>在做推荐系统之前，我们一定要先了解用户需求，然后再做用户画像。我们可以根据用户的特质来做用户画像。具体从以下几方面来举例分析，用户所处的人群属性，主要有旅游达人、有车一族、意见领袖等。用户的兴趣爱好主要分团购偏好、外卖偏好、电影偏好等。用户的基础属性，主要有性别、职业、年龄段、收入水平、婚育情况、活跃城市、教育程度等。最为重要的是，用户的行为属性，比如团购、外卖、打车、酒店和电影等，可以从下单次数、消费程度和评价质量等方面去衡量。<br>用户画像主要用于用户的精细化运营、个性化推荐、大数据报告、商户精细化运营支持和趋势分析。用户的精细化运营中主要有优惠券发放、推送推广信息、流失预警分析以及品类转新。个性化推荐则主要从兴趣爱好进行分析，比如个人的广告语的个性化推荐、团单推荐、菜品推荐和店铺推荐。当然还包括个性化推荐得到的候选集的排序。大数据报告则主要有自动化人群分析、电影大数据报告、餐饮大数据报告等。商户精细化运营支持主要有拉新策略、活动精准推送和定价策略。趋势预测主要有票房预测和销量预测。</p>
<p>如下给出用户画像分析的总体架构。<br><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_1.jpg" alt="用户画像总体架构"></p>
<h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><p>数据和特征决定了机器学习的上限，而模型和算法知识逼近这个上限而已。因此，特征工程是则是这个上限的关键一步。特征工程的目的就是最大限度地从原始数据中提取特征以供算法和模型使用。一下图中概括了特征工程的主要方面。</p>
<p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_2.jpg" alt="特征工程"></p>
<p>特种工程一般使用sklearn来处理，sklearn中提供了较为完整的特征处理方法，包括数据预处理、特征选择、降维等。具体的可以从sklearn官方文档中学习得到。</p>
<h1 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h1><p>常见的推荐算法主要有基于邻域的推荐、基于模型的推荐、基于内容的推荐等。</p>
<h2 id="基于邻域的算法"><a href="#基于邻域的算法" class="headerlink" title="基于邻域的算法"></a>基于邻域的算法</h2><p>基于邻域的算法，同小组的同事已经做了非常丰富的调研工作，这里的本次培训周总结就简略的谈一下。基于邻域的算法主要包括基于用户的协同过滤算法和基于物品的协同过滤算法。一般来说，推荐系统中会使用基于物品的协同过率算法更多。</p>
<h3 id="基于用户的协同过滤本质就是我要给你推荐物品，先找到与你兴趣最相似的K哥用户，然后把他们喜欢的而你却没有产生过行为的物品推荐给你。A对Y的喜欢-B对Y的喜欢-times-A与B的相似度。在新闻类网站中，用户的兴趣爱好往往比较粗粒度，很少会有用户说只看某个话题的新闻，往往某个话题也不是天天会有新闻的。个性化新闻推荐更强调新闻热点，热门程度和时效性是个性化新闻推荐的重点，个性化是补充，所以UserCF给用户推荐和他有相同兴趣爱好的人关注的新闻，这样在保证了热点和时效性的同时，兼顾了个性化。另外一个原因是从技术上考虑的，作为一种物品，新闻的更新非常快，而且实时会有新的新闻出现，而如果使用ItemCF的话，需要维护一张物品之间相似度的表，实际工业界这表一般是一天一更新的，这在新闻领域是万万不能接受的。"><a href="#基于用户的协同过滤本质就是我要给你推荐物品，先找到与你兴趣最相似的K哥用户，然后把他们喜欢的而你却没有产生过行为的物品推荐给你。A对Y的喜欢-B对Y的喜欢-times-A与B的相似度。在新闻类网站中，用户的兴趣爱好往往比较粗粒度，很少会有用户说只看某个话题的新闻，往往某个话题也不是天天会有新闻的。个性化新闻推荐更强调新闻热点，热门程度和时效性是个性化新闻推荐的重点，个性化是补充，所以UserCF给用户推荐和他有相同兴趣爱好的人关注的新闻，这样在保证了热点和时效性的同时，兼顾了个性化。另外一个原因是从技术上考虑的，作为一种物品，新闻的更新非常快，而且实时会有新的新闻出现，而如果使用ItemCF的话，需要维护一张物品之间相似度的表，实际工业界这表一般是一天一更新的，这在新闻领域是万万不能接受的。" class="headerlink" title="基于用户的协同过滤本质就是我要给你推荐物品，先找到与你兴趣最相似的K哥用户，然后把他们喜欢的而你却没有产生过行为的物品推荐给你。A对Y的喜欢=B对Y的喜欢\times A与B的相似度。在新闻类网站中，用户的兴趣爱好往往比较粗粒度，很少会有用户说只看某个话题的新闻，往往某个话题也不是天天会有新闻的。个性化新闻推荐更强调新闻热点，热门程度和时效性是个性化新闻推荐的重点，个性化是补充，所以UserCF给用户推荐和他有相同兴趣爱好的人关注的新闻，这样在保证了热点和时效性的同时，兼顾了个性化。另外一个原因是从技术上考虑的，作为一种物品，新闻的更新非常快，而且实时会有新的新闻出现，而如果使用ItemCF的话，需要维护一张物品之间相似度的表，实际工业界这表一般是一天一更新的，这在新闻领域是万万不能接受的。"></a>基于用户的协同过滤本质就是我要给你推荐物品，先找到与你兴趣最相似的K哥用户，然后把他们喜欢的而你却没有产生过行为的物品推荐给你。A对Y的喜欢=B对Y的喜欢\times A与B的相似度。在新闻类网站中，用户的兴趣爱好往往比较粗粒度，很少会有用户说只看某个话题的新闻，往往某个话题也不是天天会有新闻的。个性化新闻推荐更强调新闻热点，热门程度和时效性是个性化新闻推荐的重点，个性化是补充，所以UserCF给用户推荐和他有相同兴趣爱好的人关注的新闻，这样在保证了热点和时效性的同时，兼顾了个性化。另外一个原因是从技术上考虑的，作为一种物品，新闻的更新非常快，而且实时会有新的新闻出现，而如果使用ItemCF的话，需要维护一张物品之间相似度的表，实际工业界这表一般是一天一更新的，这在新闻领域是万万不能接受的。</h3><h3 id="ii-基于物品的协同过滤则先计算物品之间的相似度，根据物品的相似度和用户的历史行为生成推荐列表。A对Y的喜欢-A对X的喜欢-times-X与Y的相似度。在图书，电子商务和电影网站等方面，ItemCF则能更好的发挥作用。因为在这些网站中，用户的兴趣爱好一般是比较固定的，而且相比于新闻网站更细腻。在这些网站中，个性化推荐一般是给用户推荐他自己领域的相关物品。另外，这些网站的物品数量更新速度不快，一天一次更新可以接受。而且在这些网站中，用户数量往往远远大于物品数量，从存储的角度来讲，UserCF需要消耗更大的空间复杂度，另外，ItemCF可以方便的提供推荐理由，增加用户对推荐系统的信任度，所以更适合这些网站。"><a href="#ii-基于物品的协同过滤则先计算物品之间的相似度，根据物品的相似度和用户的历史行为生成推荐列表。A对Y的喜欢-A对X的喜欢-times-X与Y的相似度。在图书，电子商务和电影网站等方面，ItemCF则能更好的发挥作用。因为在这些网站中，用户的兴趣爱好一般是比较固定的，而且相比于新闻网站更细腻。在这些网站中，个性化推荐一般是给用户推荐他自己领域的相关物品。另外，这些网站的物品数量更新速度不快，一天一次更新可以接受。而且在这些网站中，用户数量往往远远大于物品数量，从存储的角度来讲，UserCF需要消耗更大的空间复杂度，另外，ItemCF可以方便的提供推荐理由，增加用户对推荐系统的信任度，所以更适合这些网站。" class="headerlink" title="ii.    基于物品的协同过滤则先计算物品之间的相似度，根据物品的相似度和用户的历史行为生成推荐列表。A对Y的喜欢=A对X的喜欢\times X与Y的相似度。在图书，电子商务和电影网站等方面，ItemCF则能更好的发挥作用。因为在这些网站中，用户的兴趣爱好一般是比较固定的，而且相比于新闻网站更细腻。在这些网站中，个性化推荐一般是给用户推荐他自己领域的相关物品。另外，这些网站的物品数量更新速度不快，一天一次更新可以接受。而且在这些网站中，用户数量往往远远大于物品数量，从存储的角度来讲，UserCF需要消耗更大的空间复杂度，另外，ItemCF可以方便的提供推荐理由，增加用户对推荐系统的信任度，所以更适合这些网站。"></a>ii.    基于物品的协同过滤则先计算物品之间的相似度，根据物品的相似度和用户的历史行为生成推荐列表。A对Y的喜欢=A对X的喜欢\times X与Y的相似度。在图书，电子商务和电影网站等方面，ItemCF则能更好的发挥作用。因为在这些网站中，用户的兴趣爱好一般是比较固定的，而且相比于新闻网站更细腻。在这些网站中，个性化推荐一般是给用户推荐他自己领域的相关物品。另外，这些网站的物品数量更新速度不快，一天一次更新可以接受。而且在这些网站中，用户数量往往远远大于物品数量，从存储的角度来讲，UserCF需要消耗更大的空间复杂度，另外，ItemCF可以方便的提供推荐理由，增加用户对推荐系统的信任度，所以更适合这些网站。</h3><h2 id="基于模型的推荐"><a href="#基于模型的推荐" class="headerlink" title="基于模型的推荐"></a>基于模型的推荐</h2><h3 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h3><h4 id="培训老师讲的ALS算法，交替最小二乘法，即最为基础的矩阵分解做法。目的就是通过分解user-item评分矩阵的做法来填充观测矩阵中缺失的部分。"><a href="#培训老师讲的ALS算法，交替最小二乘法，即最为基础的矩阵分解做法。目的就是通过分解user-item评分矩阵的做法来填充观测矩阵中缺失的部分。" class="headerlink" title="培训老师讲的ALS算法，交替最小二乘法，即最为基础的矩阵分解做法。目的就是通过分解user-item评分矩阵的做法来填充观测矩阵中缺失的部分。"></a>培训老师讲的ALS算法，交替最小二乘法，即最为基础的矩阵分解做法。目的就是通过分解user-item评分矩阵的做法来填充观测矩阵中缺失的部分。</h4><h4 id="用户对物品的评分可以表示成一个评分矩阵R-M-times-N-表示M个用户对N个物品的评分情况。"><a href="#用户对物品的评分可以表示成一个评分矩阵R-M-times-N-表示M个用户对N个物品的评分情况。" class="headerlink" title="用户对物品的评分可以表示成一个评分矩阵R(M\times N),表示M个用户对N个物品的评分情况。"></a>用户对物品的评分可以表示成一个评分矩阵R(M\times N),表示M个用户对N个物品的评分情况。</h4><h4 id="评分矩阵就可以通过分解成两个特征矩阵user-latent-matrix-U-K-times-M-和item-latent-matrix-K-times-N-，然后通过迭代训练这两个矩阵得到，最后的预测评分矩阵则为-hat-R-U-T-V。"><a href="#评分矩阵就可以通过分解成两个特征矩阵user-latent-matrix-U-K-times-M-和item-latent-matrix-K-times-N-，然后通过迭代训练这两个矩阵得到，最后的预测评分矩阵则为-hat-R-U-T-V。" class="headerlink" title="评分矩阵就可以通过分解成两个特征矩阵user latent matrix U(K\times M) 和item latent matrix(K\times N)，然后通过迭代训练这两个矩阵得到，最后的预测评分矩阵则为\hat{R}=U^{T}V。"></a>评分矩阵就可以通过分解成两个特征矩阵user latent matrix U(K\times M) 和item latent matrix(K\times N)，然后通过迭代训练这两个矩阵得到，最后的预测评分矩阵则为\hat{R}=U^{T}V。</h4><h4 id="通俗的讲，矩阵分解就是这么一回事，因为这里主要作个人总结，所以简单的略过自己已经会的东西。矩阵分解其实是奇异值分解的一种，这里给出我之前个人写的一个关于奇异值分解的推导博客。"><a href="#通俗的讲，矩阵分解就是这么一回事，因为这里主要作个人总结，所以简单的略过自己已经会的东西。矩阵分解其实是奇异值分解的一种，这里给出我之前个人写的一个关于奇异值分解的推导博客。" class="headerlink" title="通俗的讲，矩阵分解就是这么一回事，因为这里主要作个人总结，所以简单的略过自己已经会的东西。矩阵分解其实是奇异值分解的一种，这里给出我之前个人写的一个关于奇异值分解的推导博客。"></a>通俗的讲，矩阵分解就是这么一回事，因为这里主要作个人总结，所以简单的略过自己已经会的东西。矩阵分解其实是奇异值分解的一种，这里给出我之前个人写的一个关于奇异值分解的推导博客。</h4><h5 id="https-shouldchan-github-io-2017-11-07-E5-A5-87-E5-BC-82-E5-80-BC-E5-88-86-E8-A7-A3"><a href="#https-shouldchan-github-io-2017-11-07-E5-A5-87-E5-BC-82-E5-80-BC-E5-88-86-E8-A7-A3" class="headerlink" title="https://shouldchan.github.io/2017/11/07/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"></a><a href="https://shouldchan.github.io/2017/11/07/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/" target="_blank" rel="external">https://shouldchan.github.io/2017/11/07/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/</a></h5><h3 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h3><h4 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h4><h5 id="网页重要程度：评价物品的重要程度（在其他物品的视角上（通过关注）），通过排序得到一个推荐列表。"><a href="#网页重要程度：评价物品的重要程度（在其他物品的视角上（通过关注）），通过排序得到一个推荐列表。" class="headerlink" title="网页重要程度：评价物品的重要程度（在其他物品的视角上（通过关注）），通过排序得到一个推荐列表。"></a>网页重要程度：评价物品的重要程度（在其他物品的视角上（通过关注）），通过排序得到一个推荐列表。</h5><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_3.jpg" alt="PageRank公式"></p>
<p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_4.jpg" alt="参数解释1"></p>
<p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_5.jpg" alt="参数解释2"></p>
<h4 id="社区发现：一般结合用户对产品的喜好进行推荐，不适合在电商等用户互动比较少的场景下使用（图的节点都是用户）"><a href="#社区发现：一般结合用户对产品的喜好进行推荐，不适合在电商等用户互动比较少的场景下使用（图的节点都是用户）" class="headerlink" title="社区发现：一般结合用户对产品的喜好进行推荐，不适合在电商等用户互动比较少的场景下使用（图的节点都是用户）"></a>社区发现：一般结合用户对产品的喜好进行推荐，不适合在电商等用户互动比较少的场景下使用（图的节点都是用户）</h4><h5 id="发现网络总紧密的朋友关系"><a href="#发现网络总紧密的朋友关系" class="headerlink" title="发现网络总紧密的朋友关系"></a>发现网络总紧密的朋友关系</h5><h5 id="根据朋友关系的内容推荐相关内容"><a href="#根据朋友关系的内容推荐相关内容" class="headerlink" title="根据朋友关系的内容推荐相关内容"></a>根据朋友关系的内容推荐相关内容</h5><h2 id="基于内容的推荐"><a href="#基于内容的推荐" class="headerlink" title="基于内容的推荐"></a>基于内容的推荐</h2><h3 id="基于内容的推荐的过程"><a href="#基于内容的推荐的过程" class="headerlink" title="基于内容的推荐的过程"></a>基于内容的推荐的过程</h3><h4 id="物品表示：为每个item抽取出一些特征（即item的content）来表示此item；"><a href="#物品表示：为每个item抽取出一些特征（即item的content）来表示此item；" class="headerlink" title="物品表示：为每个item抽取出一些特征（即item的content）来表示此item；"></a>物品表示：为每个item抽取出一些特征（即item的content）来表示此item；</h4><h4 id="特征学习：利用一个用户过去喜欢（或不喜欢）的item的特征数据，来学习出此用户的喜好特征。"><a href="#特征学习：利用一个用户过去喜欢（或不喜欢）的item的特征数据，来学习出此用户的喜好特征。" class="headerlink" title="特征学习：利用一个用户过去喜欢（或不喜欢）的item的特征数据，来学习出此用户的喜好特征。"></a>特征学习：利用一个用户过去喜欢（或不喜欢）的item的特征数据，来学习出此用户的喜好特征。</h4><h4 id="生成推荐列表：通过比较上一步得到的用户profile和候选item的特征，为此用户推荐一组相关性最大的item。"><a href="#生成推荐列表：通过比较上一步得到的用户profile和候选item的特征，为此用户推荐一组相关性最大的item。" class="headerlink" title="生成推荐列表：通过比较上一步得到的用户profile和候选item的特征，为此用户推荐一组相关性最大的item。"></a>生成推荐列表：通过比较上一步得到的用户profile和候选item的特征，为此用户推荐一组相关性最大的item。</h4><h3 id="根据内容的相似性做推荐"><a href="#根据内容的相似性做推荐" class="headerlink" title="根据内容的相似性做推荐"></a>根据内容的相似性做推荐</h3><h4 id="不需要用户行为，根据物品本身的特征进行相似性分析"><a href="#不需要用户行为，根据物品本身的特征进行相似性分析" class="headerlink" title="不需要用户行为，根据物品本身的特征进行相似性分析"></a>不需要用户行为，根据物品本身的特征进行相似性分析</h4><h4 id="可以用于缓解冷启动"><a href="#可以用于缓解冷启动" class="headerlink" title="可以用于缓解冷启动"></a>可以用于缓解冷启动</h4><h4 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h4><h5 id="物品tag化-gt-物品变成向量-gt-计算相似性（文本相似性（短文本相似性（标题）、长文本相似性（简介）））"><a href="#物品tag化-gt-物品变成向量-gt-计算相似性（文本相似性（短文本相似性（标题）、长文本相似性（简介）））" class="headerlink" title="物品tag化-&gt;物品变成向量-&gt;计算相似性（文本相似性（短文本相似性（标题）、长文本相似性（简介）））"></a>物品tag化-&gt;物品变成向量-&gt;计算相似性（文本相似性（短文本相似性（标题）、长文本相似性（简介）））</h5><h5 id="文本算法"><a href="#文本算法" class="headerlink" title="文本算法"></a>文本算法</h5><h6 id="建立词库"><a href="#建立词库" class="headerlink" title="建立词库"></a>建立词库</h6><p>######文本降维：tfidf、word2vec</p>
<h5 id="产品画像数据"><a href="#产品画像数据" class="headerlink" title="产品画像数据"></a>产品画像数据</h5><h1 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h1><h2 id="在线指标"><a href="#在线指标" class="headerlink" title="在线指标"></a>在线指标</h2><h3 id="点击率"><a href="#点击率" class="headerlink" title="点击率"></a>点击率</h3><p>比如系统向用户i推荐了n部电影，单击浏览影片的个数是m；则该用户的点击率是Pi=m/n。</p>
<h3 id="转换率"><a href="#转换率" class="headerlink" title="转换率"></a>转换率</h3><h4 id="电商：推荐的销售额和总体销售额的比率；"><a href="#电商：推荐的销售额和总体销售额的比率；" class="headerlink" title="电商：推荐的销售额和总体销售额的比率；"></a>电商：推荐的销售额和总体销售额的比率；</h4><h4 id="电影：点击量或者播放时长，与总体点击量或时长的比率。"><a href="#电影：点击量或者播放时长，与总体点击量或时长的比率。" class="headerlink" title="电影：点击量或者播放时长，与总体点击量或时长的比率。"></a>电影：点击量或者播放时长，与总体点击量或时长的比率。</h4><h2 id="离线评估"><a href="#离线评估" class="headerlink" title="离线评估"></a>离线评估</h2><h3 id="MAE（平均绝对误差）"><a href="#MAE（平均绝对误差）" class="headerlink" title="MAE（平均绝对误差）"></a>MAE（平均绝对误差）</h3><h4 id="用于衡量评分的准确度"><a href="#用于衡量评分的准确度" class="headerlink" title="用于衡量评分的准确度"></a>用于衡量评分的准确度</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_6.jpg" alt="MAE公式"></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_7.jpg" alt="MAE参数解释"></h4><h3 id="PRF（准确率，召回率，F1-sccore）"><a href="#PRF（准确率，召回率，F1-sccore）" class="headerlink" title="PRF（准确率，召回率，F1-sccore）"></a>PRF（准确率，召回率，F1-sccore）</h3><h4 id="用于衡量分类的准确度"><a href="#用于衡量分类的准确度" class="headerlink" title="用于衡量分类的准确度"></a>用于衡量分类的准确度</h4><h4 id="Precision"><a href="#Precision" class="headerlink" title="Precision"></a>Precision</h4><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_8.jpg" alt="Precision公式"></h5><h5 id="准确率就是指“你的预测有多少是对的”；"><a href="#准确率就是指“你的预测有多少是对的”；" class="headerlink" title="准确率就是指“你的预测有多少是对的”；"></a>准确率就是指“你的预测有多少是对的”；</h5><h4 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h4><h5 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_9.jpg" alt="Recall公式"></h5><h5 id="召回率就是指“正例里面你的预测覆盖了多少”；"><a href="#召回率就是指“正例里面你的预测覆盖了多少”；" class="headerlink" title="召回率就是指“正例里面你的预测覆盖了多少”；"></a>召回率就是指“正例里面你的预测覆盖了多少”；</h5><h4 id="F1-score"><a href="#F1-score" class="headerlink" title="F1-score"></a>F1-score</h4><h5 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_10.jpg" alt="F1-score公式"></h5><h3 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h3><h4 id="因为PRF只是针对分对分错的情况，参考价值一般"><a href="#因为PRF只是针对分对分错的情况，参考价值一般" class="headerlink" title="因为PRF只是针对分对分错的情况，参考价值一般"></a>因为PRF只是针对分对分错的情况，参考价值一般</h4><h4 id="对于只有评分的系统，绘制ROC曲线，AUC则为ROC曲线下的面积。"><a href="#对于只有评分的系统，绘制ROC曲线，AUC则为ROC曲线下的面积。" class="headerlink" title="对于只有评分的系统，绘制ROC曲线，AUC则为ROC曲线下的面积。"></a>对于只有评分的系统，绘制ROC曲线，AUC则为ROC曲线下的面积。</h4><h3 id="MAP（平均准确度）"><a href="#MAP（平均准确度）" class="headerlink" title="MAP（平均准确度）"></a>MAP（平均准确度）</h3><h4 id="用户衡量推荐排序的好坏"><a href="#用户衡量推荐排序的好坏" class="headerlink" title="用户衡量推荐排序的好坏"></a>用户衡量推荐排序的好坏</h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_11.jpg" alt="AP公式"></h4><h4 id="MAP则是AP的值累加后求平均即可。"><a href="#MAP则是AP的值累加后求平均即可。" class="headerlink" title="MAP则是AP的值累加后求平均即可。"></a>MAP则是AP的值累加后求平均即可。</h4><h3 id="RMSE（均方根误差）"><a href="#RMSE（均方根误差）" class="headerlink" title="RMSE（均方根误差）"></a>RMSE（均方根误差）</h3><h4 id="这里给出百度百科的定义，百度总比我自己去描述的更为专业均方根误差是观测值与真值偏差的平方与观测次数n比值的平方根，在实际测量中，观测次数n总是有限的，真值只能用最可信赖（最佳）值来代替。-标准误差-对一组测量中的特大或特小误差反映非常敏感，所以，标准误差能够很好地反映出测量的精密度。这正是标准误差在工程测量中广泛被采用的原因。因此，标准差是用来衡量一组数自身的离散程度，而均方根误差是用来衡量观测值同真值之间的偏差，它们的研究对象和研究目的不同，但是计算过程类似-。"><a href="#这里给出百度百科的定义，百度总比我自己去描述的更为专业均方根误差是观测值与真值偏差的平方与观测次数n比值的平方根，在实际测量中，观测次数n总是有限的，真值只能用最可信赖（最佳）值来代替。-标准误差-对一组测量中的特大或特小误差反映非常敏感，所以，标准误差能够很好地反映出测量的精密度。这正是标准误差在工程测量中广泛被采用的原因。因此，标准差是用来衡量一组数自身的离散程度，而均方根误差是用来衡量观测值同真值之间的偏差，它们的研究对象和研究目的不同，但是计算过程类似-。" class="headerlink" title="这里给出百度百科的定义，百度总比我自己去描述的更为专业均方根误差是观测值与真值偏差的平方与观测次数n比值的平方根，在实际测量中，观测次数n总是有限的，真值只能用最可信赖（最佳）值来代替。 标准误差 对一组测量中的特大或特小误差反映非常敏感，所以，标准误差能够很好地反映出测量的精密度。这正是标准误差在工程测量中广泛被采用的原因。因此，标准差是用来衡量一组数自身的离散程度，而均方根误差是用来衡量观测值同真值之间的偏差，它们的研究对象和研究目的不同，但是计算过程类似 。"></a>这里给出百度百科的定义，百度总比我自己去描述的更为专业均方根误差是观测值与真值偏差的平方与观测次数n比值的平方根，在实际测量中，观测次数n总是有限的，真值只能用最可信赖（最佳）值来代替。 标准误差 对一组测量中的特大或特小误差反映非常敏感，所以，标准误差能够很好地反映出测量的精密度。这正是标准误差在工程测量中广泛被采用的原因。因此，标准差是用来衡量一组数自身的离散程度，而均方根误差是用来衡量观测值同真值之间的偏差，它们的研究对象和研究目的不同，但是计算过程类似 。</h4><h4 id="S-x1-x-2-x2-x-2-……-xn-x-2-N-0-5（x为平均数，N为样本个数）此公式中的X也就是所谓的平均数应改为x’1-x’2……（即真实值）。均方根误差算的是观测值与其真值，或者观测值与其模拟值之间的偏差，而不是观测值与其平均值之间的偏差。"><a href="#S-x1-x-2-x2-x-2-……-xn-x-2-N-0-5（x为平均数，N为样本个数）此公式中的X也就是所谓的平均数应改为x’1-x’2……（即真实值）。均方根误差算的是观测值与其真值，或者观测值与其模拟值之间的偏差，而不是观测值与其平均值之间的偏差。" class="headerlink" title="S={[(x1-x)^2+(x2-x)^2+……(xn-x)^2]/N}^0.5（x为平均数，N为样本个数）此公式中的X也就是所谓的平均数应改为x’1,x’2……（即真实值）。均方根误差算的是观测值与其真值，或者观测值与其模拟值之间的偏差，而不是观测值与其平均值之间的偏差。"></a>S={[(x1-x)^2+(x2-x)^2+……(xn-x)^2]/N}^0.5（x为平均数，N为样本个数）此公式中的X也就是所谓的平均数应改为x’1,x’2……（即真实值）。均方根误差算的是观测值与其真值，或者观测值与其模拟值之间的偏差，而不是观测值与其平均值之间的偏差。</h4><h3 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h3><h4 id="用于衡量相关度的排序质量评价指标"><a href="#用于衡量相关度的排序质量评价指标" class="headerlink" title="用于衡量相关度的排序质量评价指标"></a>用于衡量相关度的排序质量评价指标</h4><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_12.jpg" alt="CG公式"></p>
<h4 id="推荐结果的相关度相加（未考虑排序）"><a href="#推荐结果的相关度相加（未考虑排序）" class="headerlink" title="推荐结果的相关度相加（未考虑排序）"></a>推荐结果的相关度相加（未考虑排序）</h4><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_13.jpg" alt="DCG公式"></p>
<h4 id="排名顺序加权"><a href="#排名顺序加权" class="headerlink" title="排名顺序加权"></a>排名顺序加权</h4><p><img src="https://raw.githubusercontent.com/ShouldChan/ImageStore/master/blog_image/tuijian_14.jpg" alt="NDCG公式"></p>
<h4 id="比如在Google搜索到一个词，得到5个结果。我们对这些结果进行3个等级的区分：Good、Fair、Bad，对应的分值分别是3、2、1。假设这5个结果的分值分别是3、1、2、3、2。"><a href="#比如在Google搜索到一个词，得到5个结果。我们对这些结果进行3个等级的区分：Good、Fair、Bad，对应的分值分别是3、2、1。假设这5个结果的分值分别是3、1、2、3、2。" class="headerlink" title="比如在Google搜索到一个词，得到5个结果。我们对这些结果进行3个等级的区分：Good、Fair、Bad，对应的分值分别是3、2、1。假设这5个结果的分值分别是3、1、2、3、2。"></a>比如在Google搜索到一个词，得到5个结果。我们对这些结果进行3个等级的区分：Good、Fair、Bad，对应的分值分别是3、2、1。假设这5个结果的分值分别是3、1、2、3、2。</h4></div>

      <div class="bottom-panel">
        <ul class="social-likes" data-url="/2018/07/25/推荐培训个人总结/">
          <li class="facebook" title="like"></li>
          <li class="twitter" title="twitte"></li>
          <li class="plusone" title="google"></li>
        </ul>
      </div>
    </div>
    
  </div>

  <div class="widgetarea">

    
    

<div class="tagcloud" id="fbox-tagcloud" style="margin:10px; display:none; overflow: hidden"><a href="/tags/Machine-Learning/" style="font-size: 12px;">Machine Learning</a></div>

    

    
      

<ul class="widget blogroll">
  <h3 class="title">Recent Post</h3>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2018/08/01/数据统计小功能实现/">数据统计小功能实现</a></h3>
        <p>本周针对浙江视频推荐项目，导师提出了实现两个数据统计的工作。第一，根据已有数据，统计每部电影被观看了</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2018/07/25/推荐培训个人总结/">推荐培训个人总结</a></h3>
        <p>针对2018年7月20日至21日的推荐培训课程做的学习总结。根据本人对所学知识的梳理，本次培训主要内</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2018/07/17/关于隐反馈的一些个人见解/">关于隐反馈的一些个人见解</a></h3>
        <p>关于隐反馈的一些个人见解显式反馈和隐式反馈的区别显式反馈中，矩阵中的每个元素1-5代表用户对物品的喜</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2017/12/08/集成学习下/">集成学习下</a></h3>
        <p>横跨快有两周的时间了，补一下集成学习下的内容。上上周写了集成学习上的博客，在那一块知识，有一个很典型</p>
      </div>
    </li>
  
    
    <li>
      <div class="text-holder">
        <h3 class="link-title"><a href="/2017/11/26/集成学习上/">集成学习上</a></h3>
        <p>周中在实验室seminar上做了一个有关集成学习的报告，趁周末有空，把集成学习的相关内容写个博客。我</p>
      </div>
    </li>
  
</ul>


    

  </div>
</div>


  </div>
  
<div class="footer">
  <div class="container">
    <a href="//github.com/kywk/hexo-theme-awe">AWE for hexo</a> inspired by <a href="http://goo.gl/H8OMRE">Awesome UI Kit</a>,
    ported by <a href="//kywk.github.io/">MooCow (Aka. kywk)</a>.
    
    &copy; 2018 Should Chan All Rights Reserved
    
  </div>
</div>

  <!-- disqus -->



<script>
$(document).ready(function() {
  $('.imgLiquid').imgLiquid({fill:true, fadeInTime:500});
});
</script>


<!-- fancybox -->
<link rel="stylesheet" href="/package/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="/package/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<script type="text/javascript">
(function($){
  $(".fancybox").fancybox();
  $(".various").fancybox({
    maxWidth  : 800,
    maxHeight : 600,
    fitToView : false,
    width   : '70%',
    height    : '70%',
    autoSize  : true,
    closeClick  : false,
    openEffect  : 'none',
    closeEffect : 'none'
  });
})(jQuery);
</script>

</body>
</html>
